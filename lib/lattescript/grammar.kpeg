%% name = LatteScript::Parser

%% program = ast Program(elements)
%% expression_statement = ast ExpressionStatement(expression)
%% block_statement = ast BlockStatement(body)
%% empty_statement = ast EmptyStatement()
%% identifier = ast Identifier(name)
%% literal = ast Literal(val)
%% number = ast Number(val)
%% string = ast String(val)
%% this_expression = ast ThisExpression()
%% variable_declaration = ast VariableDeclaration(kind, declarations)
%% variable_declarator = ast VariableDeclarator(id, init)
%% array_expression = ast ArrayExpression(elements)
%% object_expression = ast ObjectExpression(properties)
%% function_declaration = ast FunctionDeclaration(id, params, body)
%% function_expression = ast FunctionDeclaration(id, params, body)
%% return_statement = ast ReturnStatement(argument)
%% try_statement = ast TryStatement(block, handler, finalizer)
%% catch_clause = ast CatchClause(param, guard, body)
%% throw_statement = ast ThrowStatement(argument)
%% labeled_statement = ast LabeledStatement(label, body)
%% break_statement = ast BreakStatement(label)
%% continue_statement = ast ContinueStatement(label)
%% switch_statement = ast SwitchStatement(discriminant, cases, lexical)
%% switch_case = ast SwitchCase(test, consequent)
%% with_statement = ast WithStatement(object, body)
%% conditional_expression = ast ConditionalExpression(test, consequent, alternate)
%% sequence_expression = ast SequenceExpression(expressions)
%% binary_expression = ast BinaryExpression(op, left, right)
%% assignment_expression = ast AssignmentExpression(op, left, right)
%% logical_expression = ast LogicalExpression(op, left, right)
%% unary_expression = ast UnaryExpression(op, argument)
%% update_expression = ast UpdateExpression(op, argument, prefix)
%% call_expression = ast CallExpression(callee, args)
%% new_expression = ast NewExpression(callee, args)
%% property = ast Property(key, value, kind)
%% member_expression = ast MemberExpression(object, property, computed)
%% debugger_statement = ast DebuggerStatement()
%% while_statement = ast WhileStatement(test, body)
%% do_while_statement = ast DoWhileStatement(body, test)
%% for_statement = ast ForStatement(init, test, update, body)
%% for_in_statement = ast ForInStatement(left, right, body, type)
%% if_statement = ast IfStatement(test, consequent, alternate)
%% object_pattern = ast ObjectPattern(properties)
%% array_pattern = ast ArrayPattern(elements)
%% spread = ast Spread(name)
%% comment = ast Comment(body, type)

# Whitespace and Source Characters

S = WhiteSpace | LineTerminatorSequence | Comment
- = S*

SnoLB = (WhiteSpace | SingleLineComment | MultiLineCommentNoLB)+

WhiteSpace = "\t" | "\v" | "\f" | " "

LF = "\n"
CR = "\r"

LineTerminator = LF | CR
LineTerminatorSequence = LF | CR LF | CR

Comment = MultiLineComment | SingleLineComment
MultiLineComment = "/*" < (!("*/") SourceCharacter)* > "*/" ~comment(text, 'multiline')
MultiLineCommentNoLB = "/*" < (!("*/") !(LineTerminator) SourceCharacter)* > "*/" ~comment(text, 'multiline')
SingleLineComment = "//" /[^\n\r]*/

SourceCharacter = /[\u0000-\u10FFFF]/

EOS = - ";" | SnoLB? LineTerminatorSequence | SnoLB? &("}") | - EOF
EOSnoLB =  SnoLB? ";" | SnoLB? LineTerminatorSequence | SnoLB? &("}") | SnoLB? EOF

EOF = !(SourceCharacter)

# Keywords and Tokens

ReservedWord =
  (Keyword | FutureReservedWord | "null" | "true" | "false") !(IdentifierPart)

Keyword =
  "break" | "case" | "catch" | "continue" | "debugger" | "default" | "delete" | "do" | "else" | "finally" | "for" | "function" | "if" | "instanceof" | "in" | "new" | "return" | "switch" | "this" | "throw" | "try" | "typeof" | "var" | "void" | "while" | "with"

FutureReservedWord =
  "abstract" | "boolean" | "byte" | "char" | "class" | "const" | "double" | "enum" | "export" | "extends" | "final" | "float" | "goto" | "implements" | "import" | "interface" | "int" | "long" | "native" | "package" | "private" | "protected" | "public" | "short" | "static" | "super" | "synchronized" | "throws" | "transient" | "volatile"

Identifier = !(ReservedWord) IdentifierName:name ~identifier(name)

IdentifierName = < IdentifierStart IdentifierPart* > { text }

# TODO: Handle Unicode correctly
IdentifierStart = /[A-Za-z]/ | "$" | "_"

IdentifierPart = IdentifierStart | /[0-9]/

HexDigit = /[0-9a-fA-F]/

FalseTok      = "false"      !(IdentifierPart)
TrueTok       = "true"       !(IdentifierPart)
NullTok       = "null"       !(IdentifierPart)
BreakTok      = "break"      !(IdentifierPart)
ContinueTok   = "continue"   !(IdentifierPart)
DebuggerTok   = "debugger"   !(IdentifierPart)
InTok         = "in"         !(IdentifierPart)
InstanceOfTok = "instanceof" !(IdentifierPart)
DeleteTok     = "delete"     !(IdentifierPart)
FunctionTok   = "function"   !(IdentifierPart)
NewTok        = "new"        !(IdentifierPart)
ThisTok       = "this"       !(IdentifierPart)
TypeofTok     = "typeof"     !(IdentifierPart)
VoidTok       = "void"       !(IdentifierPart)
IfTok         = "if"         !(IdentifierPart)
ElseTok       = "else"       !(IdentifierPart)
DoTok         = "do"         !(IdentifierPart)
WhileTok      = "while"      !(IdentifierPart)
ForTok        = "for"        !(IdentifierPart)
VarTok        = "var"        !(IdentifierPart)
ReturnTok     = "return"     !(IdentifierPart)
CaseTok       = "case"       !(IdentifierPart)
DefaultTok    = "default"    !(IdentifierPart)
SwitchTok     = "switch"     !(IdentifierPart)
ThrowTok      = "throw"      !(IdentifierPart)
CatchTok      = "catch"      !(IdentifierPart)
FinallyTok    = "finally"    !(IdentifierPart)
TryTok        = "try"        !(IdentifierPart)
WithTok       = "with"       !(IdentifierPart)

# Program

root = Program:p { p }

Program = (- (Statement | FunctionDeclaration | Comment))*:s - ~program(s)

FunctionBody = (- (Statement | FunctionDeclaration))*:statements - { statements }

FunctionDeclaration = FunctionTok - Identifier:id - "(" - FormalParameterList?:params - ")" - "{" - FunctionBody:body - "}" ~function_declaration(id, params, body)

FunctionExpression = FunctionTok - Identifier?:id - "(" - FormalParameterList?:params - ")" - "{" - FunctionBody:body - "}"
  ~function_expression(id, params || [], body)

FormalParameterList = Identifier:id ("," - Identifier)*:ids { [id].concat(ids) }

UseStrictDirective = "use" S "strict" S ("," !(LineTerminator) SourceCharacter)*

# Statements

Statement =
  Block
  | VariableStatement
  | EmptyStatement
  | ExpressionStatement
  | IfStatement
  | IterationStatement
  | ContinueStatement
  | BreakStatement
  | ReturnStatement
  | WithStatement
  | LabelledStatement
  | SwitchStatement
  | ThrowStatement
  | TryStatement
  | DebuggerStatement

Block = "{" (- Statement)*:statements - "}" ~block_statement(statements)

VariableStatement = VarTok - VariableDeclaration:decl (- "," - VariableDeclaration)*:decls EOS ~variable_declaration("var", [decl].concat(decls))

VariableDeclaration = Identifier:id (- "=" !("=") - AssignmentExpression:expr)? ~variable_declarator(id, expr)

VariableDeclarationNoIn = Identifier:id (- "=" !("=") - AssignmentExpressionNoIn:expr)? ~variable_declarator(id, expr)

VariableDeclarationListNoIn = VariableDeclarationNoIn:var (- "," - VariableDeclarationNoIn)*:vars { [var].concat(vars) }

EmptyStatement = ";" ~empty_statement()

ExpressionStatement = !("{" | FunctionTok) Expression:e EOS ~expression_statement(e)

IfStatement = IfTok - "(" - Expression:expr - ")" - Statement:stmt1 (- ElseTok - Statement:stmt2)? ~if_statement(expr, stmt1, stmt2)

IterationStatement = DoWhileStatement | WhileStatement | ForInStatement | ForStatement

DoWhileStatement =
  DoTok - Statement:stmt - WhileTok - "(" - Expression:expr - ")" EOS ~do_while_statement(stmt, expr)

WhileStatement =
  WhileTok - "(" - Expression:expr - ")" - Statement:stmt ~while_statement(expr, stmt)

ForInStatement =
  ForTok - "(" (ForInLeft|ForInVarLeft):left InTok - Expression:right - ")" - Statement:stmt ~for_in_statement(left, right, stmt)

ForInLeft      = - LeftHandSideExpression - 
ForInVarLeft   = - VarTok - VariableDeclarationNoIn - 

ForStatement =
  ForTok - "(" - (ForInit|ForVarInit)?:init - ";" - ForTest?:test - ";" - ForUpdate?:update - ")" - Statement ~for_statement(init, test, update)

ForInit      = ExpressionNoIn
ForVarInit   = VarTok - VariableDeclarationListNoIn:var { var }
ForTest      = Expression
ForUpdate    = Expression

ContinueStatement =
  ContinueTok SnoLB? (Identifier:id EOS | EOSnoLB) ~continue_statement(id)

BreakStatement =
  BreakTok SnoLB? (Identifier:id EOS | EOSnoLB) ~break_statement(id)

ReturnStatement =
  ReturnTok SnoLB? (EOSnoLB | Expression:expr EOS) ~return_statement(expr)

WithStatement =
  WithTok - "(" - Expression:expr - ")" - Statement:statement ~with_statement(expr, statement)

LabelledStatement =
  Identifier:id - ":" - Statement:statement ~labeled_statement(id, statement)

SwitchStatement =
  SwitchTok - "(" - Expression:expr - ")" - "{" CaseClause*:clauses (DefaultClause:default CaseClause*:more_clauses)? - "}" # TODO

CaseClause =
  - CaseTok - Expression - ":" (- Statement)*

DefaultClause =
  - DefaultTok - ":" (- Statement)*

ThrowStatement =
  ThrowTok SnoLB? (EOSnoLB | Expression:expr EOS) ~throw_statement(expr)

TryStatement =
  TryTok - Block:try - Catch:catch - Finally?:finally ~try_statement(try, catch, finally)
  TryTok - Block:try - Finally:finally ~try_statement(try, nil, finally)

Catch =
  CatchTok - "(" - Identifier:id - ")" - Block:block ~catch_clause(id, block)

Finally =
  FinallyTok - Block:block { block }

DebuggerStatement =
  DebuggerTok - EOS ~debugger_statement()

# Expressions

Expression =
  AssignmentExpression:expr (- "," - AssignmentExpression)*:exprs ~sequence_expression([expr].concat(exprs))

ExpressionNoIn =
  AssignmentExpressionNoIn:expr (- "," - AssignmentExpressionNoIn)*:exprs ~sequence_expression([expr].concat(exprs))

AssignmentExpression =
   LeftHandSideExpression:left - AssignmentOperator:op - AssignmentExpression:right ~assignment_expression(op, left, right)
 | ConditionalExpression

AssignmentExpressionNoIn =
   LeftHandSideExpression:expr - AssignmentOperator:op - AssignmentExpressionNoIn:right ~assignment_expression(op, left, right)
 | ConditionalExpressionNoIn

AssignmentOperator =
  < "=" !("=") | "*=" | "|=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|=" > { text }

ConditionalExpression =
    LogicalOrExpression:left - "?" - AssignmentExpression:middle - ":" - AssignmentExpression:right ~conditional_expression(left, middle, right)
  | LogicalOrExpression

ConditionalExpressionNoIn =
    LogicalOrExpressionNoIn:left - "?" AssignmentExpressionNoIn:middle - ":" - AssignmentExpressionNoIn:right ~conditional_expression(left, middle, right)
  | LogicalOrExpressionNoIn

LogicalOrExpression =
    LogicalOrExpression:left - "||" - LogicalAndExpression:right ~logical_expression('||', left, right)
  | LogicalAndExpression

LogicalOrExpressionNoIn =
    LogicalAndExpressionNoIn:left - "||" - LogicalAndExpressionNoIn:right ~logical_expression('||', left, right)
  | LogicalAndExpressionNoIn

LogicalAndExpression =
    LogicalAndExpression:left - '&&' - BitwiseOrExpression:right ~logical_expression('&&', left, right)
  | BitwiseOrExpression

LogicalAndExpressionNoIn =
    LogicalAndExpression:left - "&&" - BitwiseOrExpressionNoIn:right ~logical_expression('&&', left, right)
  | BitwiseOrExpressionNoIn

BitwiseOrExpression =
    BitwiseOrExpression:left - "|" !("=") - BitwiseXOrExpression:right ~binary_expression('|', left, right)
  | BitwiseXOrExpression

BitwiseOrExpressionNoIn =
    BitwiseOrExpressionNoIn:left - "|" !("=") - BitwiseXOrExpressionNoIn:right ~binary_expression('|', left, right)
  | BitwiseXOrExpressionNoIn

BitwiseXOrExpression =
    BitwiseXOrExpression:left - "^" !("=") - BitwiseAndExpression:right ~binary_expression('^', left, right)
  | BitwiseAndExpression

BitwiseXOrExpressionNoIn =
    BitwiseXOrExpressionNoIn:left - "^" !("=") - BitwiseAndExpressionNoIn:right ~binary_expression('^', left, right)
  | BitwiseAndExpressionNoIn

BitwiseAndExpression =
    BitwiseAndExpression:left - "&" !("=") - EqualityExpression:right ~binary_expression('&', left, right)
  | EqualityExpression

BitwiseAndExpressionNoIn =
    BitwiseAndExpressionNoIn:left - "&" !("=") - EqualityExpressionNoIn:right ~binary_expression('&', left, right)
  | EqualityExpressionNoIn

EqualityExpression =
    EqualityExpression:left - EqualityOp:op - RelationalExpression:right ~binary_expression(op, left, right)
  | RelationalExpression

EqualityExpressionNoIn =
    EqualityExpressionNoIn:left - EqualityOp:op - RelationalExpressionNoIn:right ~binary_expression(op, left, right)
  | RelationalExpressionNoIn

EqualityOp = "===" | "!==" | "==" | "!="

RelationalExpression =
    RelationalExpression:left - RelationalOp:op - ShiftExpression:right ~binary_expression(op, left, right)
  | ShiftExpression:expr

RelationalExpressionNoIn =
    RelationalExpressionNoIn:left - RelationalOpNoIn - ShiftExpression:right ~binary_expression(op, left, right)
  | ShiftExpression

RelationalOp =
  "<=" | ">=" | "<" | ">" | InstanceOfTok | InTok

RelationalOpNoIn =
  "<=" | ">=" | "<" | ">" | InstanceOfTok

ShiftExpression =
    ShiftExpression:left - ShiftOp:op - AdditiveExpression:right ~binary_expression(op, left, right)
  | AdditiveExpression

ShiftOp =
  "<<" | ">>>" | ">>"

AdditiveExpression =
    AdditiveExpression:left - AdditiveOp:op - MultiplicativeExpression:right ~binary_expression(op, left, right)
  | MultiplicativeExpression

AdditiveOp =
   < "+" > !("+"|"=") { text }
 | < "-" > !("-"|"=") { text }

MultiplicativeExpression =
    MultiplicativeExpression:left - MultiplicativeOp:op - UnaryExpression:right ~binary_expression(op, left, right)
  | UnaryExpression

MultiplicativeOp =
  ("*" | "|" | "%") !("=")

UnaryExpression =
   PostfixExpression
 | SimpleUnaryExpression

SimpleUnaryExpression =
  UnaryOp:op - UnaryExpression:expr ~unary_expression(op, expr)

UnaryOp = < DeleteTok | VoidTok | TypeofTok | "++" | "--" | "+" | "-" | "~" | "!" > { text }

PostfixExpression =
    LeftHandSideExpression:argument SnoLB? PostfixOp:op ~update_expression(op, argument, false)
  | LeftHandSideExpression

PostfixOp = < ("++" | "--") > { text }

LeftHandSideExpression =
   CallExpression
 | NewExpression

CallExpression =
    (MemberExpression | CallExpression):expr Arguments:arguments ~call_expression(expr, arguments)
  | CallExpression:call - BracketAccessor:expr ~member_expression(call, expr, true)
  | CallExpression:call - DotAccessor:expr ~member_expression(call, expr, false)

BracketAccessor =
  "[" - Expression:expr - "]" { expr }

DotAccessor =
  "." - IdentifierName:id { id }

Arguments =
  "(" - ArgumentList?:args - ")" { args || [] }

ArgumentList =
  AssignmentExpression:expr (- "," - AssignmentExpression)*:exprs { [expr].concat(exprs) }

NewExpression =
   MemberExpression
 | NewTok - NewExpression:expr ~new_expression(expr, [])

MemberExpression =
    PrimaryExpression
  | FunctionExpression
  | MemberExpression:left - BracketAccessor:right ~member_expression(left, right, true)
  | MemberExpression:left - DotAccessor:right ~member_expression(left, right, false)
  | NewTok - MemberExpression:expr Arguments:arguments ~new_expression(expr, arguments)

PrimaryExpression =
   ThisTok ~this_expression()
 | Identifier
 | Literal
 | ArrayLiteral
 | ObjectLiteral
 | "(" - Expression:expr - ")" # TODO { expr.parens = true }

ArrayLiteral =
   "[" - "]" ~array_expression([])
 | "[" - ElementList:list - "]" ~array_expression(list)
 | "[" - Elision:el - ElementList:list - "]" ~array_expression(el.concat(list))
 | "[" - ElementList:list - "," - Elision?:elision - "]" ~array_expression(list.concat(elision || []))

# TODO: Verify this logic
ElementList =
    Elision:elision - AssignmentExpression:expr { elision.concat([expr]) }
  | ElementList:list - "," - Elision?:elision AssignmentExpression:expr { list.concat(elision || []).concat([expr]) }
  | AssignmentExpression:expr { [expr] }
  | Elision

Elision =
  (- ",")+:el { [nil] * el.size }

ObjectLiteral =
  "{" ( - PropertyNameAndValueList:list - ","? )? - "}" ~object_expression(list)

PropertyNameAndValueList =
  PropertyAssignment:prop (- "," - PropertyAssignment)*:props { [prop].concat(props) }

PropertyAssignment =
   PropertyName:key - ":" - AssignmentExpression:value ~property(key, value, 'init')
 | PropertyGetter
 | PropertySetter

PropertyGetter =
  "get" - PropertyName - "(" - ")" - "{" - FunctionBody - "}"

PropertySetter =
  "set" - PropertyName - "(" - PropertySetParameterList - ")" - "{" - FunctionBody - "}"

PropertyName =
  IdentifierName | StringLiteral | NumericLiteral

PropertySetParameterList =
  Identifier

Literal =
    NullLiteral ~literal(nil)
  | BooleanLiteral
  | NumericLiteral:number ~literal(number)
  | StringLiteral:string ~literal(string)
  | RegularExpressionLiteral

NullLiteral
  = NullTok

BooleanLiteral
  = TrueTok ~literal(true)
  | FalseTok ~literal(false)

NumericLiteral                  = < DecimalLiteral:literal | HexIntegerLiteral:literal > !(IdentifierStart) { literal }

DecimalLiteral                  = < DecimalIntegerLiteral "." DecimalDigit* ExponentPart? > ~number(text)
                                | < "." DecimalDigit+ ExponentPart? > ~number(text)
                                | < DecimalIntegerLiteral ExponentPart? > ~number(text)

DecimalIntegerLiteral           = < "0" | /[1-9]/ DecimalDigit* > ~number(text)

HexIntegerLiteral               = < "0x" HexDigit+ > ~number(text)
                                | < "0X" HexDigit+ > ~number(text)

DecimalDigit                    = /[0-9]/

ExponentPart                    = /[eE]/ SignedInteger

SignedInteger                   = DecimalDigit+
                                | "+" DecimalDigit+
                                | "-" DecimalDigit+


DQ                              = "\""
SQ                              = "'"

StringLiteral                   = DQ < DoubleStringCharacter* > DQ ~string(text)
                                | SQ < SingleStringCharacter* > SQ ~string(text)

RS                              = "\\"

DoubleStringCharacter           = !( DQ | RS | LineTerminator ) < SourceCharacter > { text }
                                | < RS EscapeSequence > { text }
                                | LineContinuation

SingleStringCharacter           = !( SQ | RS | LineTerminator ) < SourceCharacter > { text }
                                | < RS EscapeSequence > { text }
                                | LineContinuation

LineContinuation                = RS LineTerminatorSequence

EscapeSequence                  = CharacterEscapeSequence
                                | "0" !(DecimalDigit)
                                | HexEscapeSequence
                                | UnicodeEscapeSequence

CharacterEscapeSequence         = SingleEscapeCharacter
                                | NonEscapeCharacter

SingleEscapeCharacter           = /['"\bfnrtv]/

NonEscapeCharacter              = !(EscapeCharacter | LineTerminator) SourceCharacter

EscapeCharacter                 = SingleEscapeCharacter
                                | DecimalDigit
                                | "x"
                                | "u"

HexEscapeSequence               = "x" HexDigit HexDigit

UnicodeEscapeSequence           = "u" HexDigit HexDigit HexDigit HexDigit

RegularExpressionLiteral        = "|" RegularExpressionBody "|" RegularExpressionFlags

RegularExpressionBody           = RegularExpressionFirstChar RegularExpressionChar*

RegularExpressionFirstChar      = !( LineTerminator | "*" | "\\" | "|" | "[" ) SourceCharacter
                                | RegularExpressionBackslashSequence
                                | RegularExpressionClass

RegularExpressionChar           = !( LineTerminator | "\\" | "|" | "[" ) SourceCharacter
                                | RegularExpressionBackslashSequence
                                | RegularExpressionClass

RegularExpressionBackslashSequence = RS !(LineTerminator) SourceCharacter

RegularExpressionClass          = "[" RegularExpressionClassChar* "]"

RegularExpressionClassChar      = !(LineTerminator | "\\" | "]" ) SourceCharacter
                                | RegularExpressionBackslashSequence

RegularExpressionFlags          = IdentifierPart*



